<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pygame.Surface &mdash; Pygame v1.9.2 documentation</title>
    
    <link rel="stylesheet" href="../_static/pygame.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.9.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/pygame.ico"/>
    <link rel="top" title="Pygame v1.9.2 documentation" href="../index.html" />
    <link rel="next" title="pygame.surfarray" href="surfarray.html" />
    <link rel="prev" title="pygame.sprite" href="sprite.html" /> 
  </head>
  <body>  

    <div class="document">

  <div class="header">
    <table>
      <tr>
	<td class="logo">
	  <a href="http://www.pygame.org/">
	    <img src="../_static/pygame_tiny.png"/>
	  </a>
	  <h5>pygame documentation</h5>
	</td>
	<td class="pagelinks">
	  <p class="top">
	    <a href="http://www.pygame.org/">Pygame Home</a> ||
	    <a href="../index.html">Help Contents</a> ||
	    <a href="../genindex.html">Reference Index</a>
	  </p>
	  <p class="bottom">
	    <a href="bufferproxy.html">BufferProxy</a> | 
	    <a href="camera.html">camera</a> | 
	    <a href="cdrom.html">cdrom</a> | 
	    <a href="color.html">Color</a> | 
	    <a href="cursors.html">cursors</a> | 
	    <a href="display.html">display</a> | 
	    <a href="draw.html">draw</a> | 
	    <a href="event.html">event</a> | 
	    <a href="examples.html">examples</a> | 
	    <a href="font.html">font</a> | 
	    <a href="freetype.html">freetype</a> | 
	    <a href="gfxdraw.html">gfxdraw</a> | 
	    <a href="image.html">image</a> | 
	    <a href="joystick.html">joystick</a> | 
	    <a href="key.html">key</a> | 
	    <a href="locals.html">locals</a> | 
	    <a href="mask.html">mask</a> | 
	    <a href="math.html">math</a> | 
	    <a href="midi.html">midi</a> | 
	    <a href="mixer.html">mixer</a> | 
	    <a href="mouse.html">mouse</a> | 
	    <a href="music.html">music</a> | 
	    <a href="overlay.html">Overlay</a> | 
	    <a href="pixelarray.html">PixelArray</a> | 
	    <a href="pixelcopy.html">pixelcopy</a> | 
	    <a href="pygame.html">pygame</a> | 
	    <a href="rect.html">Rect</a> | 
	    <a href="scrap.html">scrap</a> | 
	    <a href="sndarray.html">sndarray</a> | 
	    <a href="sprite.html">sprite</a> | 
	    <a href="surface.html">Surface</a> | 
	    <a href="surfarray.html">surfarray</a> | 
	    <a href="tests.html">tests</a> | 
	    <a href="time.html">time</a> | 
	    <a href="transform.html">transform</a> | 
	    <a href="pygame.html#module-pygame.version">version</a>
	  </p>
	</td>
      </tr>
    </table>
  </div>

      <div class="documentwrapper">
          <div class="body">
            
  <div class="sectionwrapper">
    <h1><tt class="docutils literal"><span class="pre">pygame.Surface</span></tt></h1>
<div class="section" id="pygame-surface">
<dl class="definition class">
<dt class="title" id="pygame.Surface">
<em class="property">class </em><tt class="descclassname">pygame.</tt><tt class="descname">Surface</tt><a class="headerlink" href="#pygame.Surface" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">pygame object for representing images</span></div>
<div class="line"><span class="signature">Surface((width, height), flags=0, depth=0, masks=None) -&gt; Surface</span></div>
<div class="line"><span class="signature">Surface((width, height), flags=0, Surface) -&gt; Surface</span></div>
</div>
<table border="1" class="toc docutils">
<colgroup>
<col width="28%" />
<col width="1%" />
<col width="71%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.blit">pygame.Surface.blit</a></td>
<td>—</td>
<td>draw one image onto another</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.convert">pygame.Surface.convert</a></td>
<td>—</td>
<td>change the pixel format of an image</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.convert_alpha">pygame.Surface.convert_alpha</a></td>
<td>—</td>
<td>change the pixel format of an image including per pixel alphas</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.copy">pygame.Surface.copy</a></td>
<td>—</td>
<td>create a new copy of a Surface</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.fill">pygame.Surface.fill</a></td>
<td>—</td>
<td>fill Surface with a solid color</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.scroll">pygame.Surface.scroll</a></td>
<td>—</td>
<td>Shift the surface image in place</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_colorkey">pygame.Surface.set_colorkey</a></td>
<td>—</td>
<td>Set the transparent colorkey</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_colorkey">pygame.Surface.get_colorkey</a></td>
<td>—</td>
<td>Get the current transparent colorkey</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_alpha">pygame.Surface.set_alpha</a></td>
<td>—</td>
<td>set the alpha value for the full Surface image</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_alpha">pygame.Surface.get_alpha</a></td>
<td>—</td>
<td>get the current Surface transparency value</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.lock">pygame.Surface.lock</a></td>
<td>—</td>
<td>lock the Surface memory for pixel access</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.unlock">pygame.Surface.unlock</a></td>
<td>—</td>
<td>unlock the Surface memory from pixel access</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.mustlock">pygame.Surface.mustlock</a></td>
<td>—</td>
<td>test if the Surface requires locking</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_locked">pygame.Surface.get_locked</a></td>
<td>—</td>
<td>test if the Surface is current locked</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_locks">pygame.Surface.get_locks</a></td>
<td>—</td>
<td>Gets the locks for the Surface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_at">pygame.Surface.get_at</a></td>
<td>—</td>
<td>get the color value at a single pixel</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_at">pygame.Surface.set_at</a></td>
<td>—</td>
<td>set the color value for a single pixel</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_at_mapped">pygame.Surface.get_at_mapped</a></td>
<td>—</td>
<td>get the mapped color value at a single pixel</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_palette">pygame.Surface.get_palette</a></td>
<td>—</td>
<td>get the color index palette for an 8bit Surface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_palette_at">pygame.Surface.get_palette_at</a></td>
<td>—</td>
<td>get the color for a single entry in a palette</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_palette">pygame.Surface.set_palette</a></td>
<td>—</td>
<td>set the color palette for an 8bit Surface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_palette_at">pygame.Surface.set_palette_at</a></td>
<td>—</td>
<td>set the color for a single index in an 8bit Surface palette</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.map_rgb">pygame.Surface.map_rgb</a></td>
<td>—</td>
<td>convert a color into a mapped color value</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.unmap_rgb">pygame.Surface.unmap_rgb</a></td>
<td>—</td>
<td>convert a mapped integer color value into a Color</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_clip">pygame.Surface.set_clip</a></td>
<td>—</td>
<td>set the current clipping area of the Surface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_clip">pygame.Surface.get_clip</a></td>
<td>—</td>
<td>get the current clipping area of the Surface</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.subsurface">pygame.Surface.subsurface</a></td>
<td>—</td>
<td>create a new surface that references its parent</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_parent">pygame.Surface.get_parent</a></td>
<td>—</td>
<td>find the parent of a subsurface</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_abs_parent">pygame.Surface.get_abs_parent</a></td>
<td>—</td>
<td>find the top level parent of a subsurface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_offset">pygame.Surface.get_offset</a></td>
<td>—</td>
<td>find the position of a child subsurface inside a parent</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_abs_offset">pygame.Surface.get_abs_offset</a></td>
<td>—</td>
<td>find the absolute position of a child subsurface inside its top level parent</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_size">pygame.Surface.get_size</a></td>
<td>—</td>
<td>get the dimensions of the Surface</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_width">pygame.Surface.get_width</a></td>
<td>—</td>
<td>get the width of the Surface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_height">pygame.Surface.get_height</a></td>
<td>—</td>
<td>get the height of the Surface</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_rect">pygame.Surface.get_rect</a></td>
<td>—</td>
<td>get the rectangular area of the Surface</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_bitsize">pygame.Surface.get_bitsize</a></td>
<td>—</td>
<td>get the bit depth of the Surface pixel format</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_bytesize">pygame.Surface.get_bytesize</a></td>
<td>—</td>
<td>get the bytes used per Surface pixel</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_flags">pygame.Surface.get_flags</a></td>
<td>—</td>
<td>get the additional flags used for the Surface</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_pitch">pygame.Surface.get_pitch</a></td>
<td>—</td>
<td>get the number of bytes used per Surface row</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_masks">pygame.Surface.get_masks</a></td>
<td>—</td>
<td>the bitmasks needed to convert between a color and a mapped integer</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_masks">pygame.Surface.set_masks</a></td>
<td>—</td>
<td>set the bitmasks needed to convert between a color and a mapped integer</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_shifts">pygame.Surface.get_shifts</a></td>
<td>—</td>
<td>the bit shifts needed to convert between a color and a mapped integer</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.set_shifts">pygame.Surface.set_shifts</a></td>
<td>—</td>
<td>sets the bit shifts needed to convert between a color and a mapped integer</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_losses">pygame.Surface.get_losses</a></td>
<td>—</td>
<td>the significant bits used to convert between a color and a mapped integer</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_bounding_rect">pygame.Surface.get_bounding_rect</a></td>
<td>—</td>
<td>find the smallest rect containing data</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_view">pygame.Surface.get_view</a></td>
<td>—</td>
<td>return a buffer view of the Surface&#8217;s pixels.</td>
</tr>
<tr class="row-odd"><td><a class="toc reference external" href="surface.html#pygame.Surface.get_buffer">pygame.Surface.get_buffer</a></td>
<td>—</td>
<td>acquires a buffer object for the pixels of the Surface.</td>
</tr>
<tr class="row-even"><td><a class="toc reference external" href="surface.html#pygame.Surface._pixels_address">pygame.Surface._pixels_address</a></td>
<td>—</td>
<td>pixel buffer address</td>
</tr>
</tbody>
</table>
<p>A pygame Surface is used to represent any image. The Surface has a fixed
resolution and pixel format. Surfaces with 8bit pixels use a color palette
to map to 24bit color.</p>
<p>Call <tt class="docutils literal"><span class="pre">pygame.Surface()</span></tt> to create a new image object. The Surface will be
cleared to all black. The only required arguments are the sizes. With no
additional arguments, the Surface will be created in a format that best
matches the display Surface.</p>
<p>The pixel format can be controlled by passing the bit depth or an existing
Surface. The flags argument is a bitmask of additional features for the
surface. You can pass any combination of these flags:</p>
<div class="highlight-python"><div class="highlight"><pre>HWSURFACE, creates the image in video memory
SRCALPHA, the pixel format will include a per-pixel alpha
</pre></div>
</div>
<p>Both flags are only a request, and may not be possible for all displays and
formats.</p>
<p>Advance users can combine a set of bitmasks with a depth value. The masks
are a set of 4 integers representing which bits in a pixel will represent
each color. Normal Surfaces should not require the masks argument.</p>
<p>Surfaces can have many extra attributes like alpha planes, colorkeys, source
rectangle clipping. These functions mainly effect how the Surface is blitted
to other Surfaces. The blit routines will attempt to use hardware
acceleration when possible, otherwise they will use highly optimized
software blitting methods.</p>
<p>There are three types of transparency supported in Pygame: colorkeys,
surface alphas, and pixel alphas. Surface alphas can be mixed with
colorkeys, but an image with per pixel alphas cannot use the other modes.
Colorkey transparency makes a single color value transparent. Any pixels
matching the colorkey will not be drawn. The surface alpha value is a single
value that changes the transparency for the entire image. A surface alpha of
255 is opaque, and a value of 0 is completely transparent.</p>
<p>Per pixel alphas are different because they store a transparency value for
every pixel. This allows for the most precise transparency effects, but it
also the slowest. Per pixel alphas cannot be mixed with surface alpha and
colorkeys.</p>
<p>There is support for pixel access for the Surfaces. Pixel access on hardware
surfaces is slow and not recommended. Pixels can be accessed using the
<tt class="docutils literal"><span class="pre">get_at()</span></tt> and <tt class="docutils literal"><span class="pre">set_at()</span></tt> functions. These methods are fine for simple
access, but will be considerably slow when doing of pixel work with them. If
you plan on doing a lot of pixel level work, it is recommended to use a
<a class="tooltip reference internal" href="pixelarray.html#pygame.PixelArray" title=""><tt class="xref py py-class docutils literal"><span class="pre">pygame.PixelArray</span></tt><span class="tooltip-content">pygame object for direct pixel access of surfaces</span></a>, which gives an array like view of the surface.
For involved mathematical manipulations try the <a class="tooltip reference internal" href="surfarray.html#module-pygame.surfarray" title=""><tt class="xref py py-mod docutils literal"><span class="pre">pygame.surfarray</span></tt><span class="tooltip-content">pygame module for accessing surface pixel data using array interfaces</span></a>
module (It&#8217;s quite quick, but requires NumPy.)</p>
<p>Any functions that directly access a surface&#8217;s pixel data will need that
surface to be lock()&#8217;ed. These functions can <tt class="docutils literal"><span class="pre">lock()</span></tt> and <tt class="docutils literal"><span class="pre">unlock()</span></tt> the
surfaces themselves without assistance. But, if a function will be called
many times, there will be a lot of overhead for multiple locking and
unlocking of the surface. It is best to lock the surface manually before
making the function call many times, and then unlocking when you are
finished. All functions that need a locked surface will say so in their
docs. Remember to leave the Surface locked only while necessary.</p>
<p>Surface pixels are stored internally as a single number that has all the
colors encoded into it. Use the <tt class="docutils literal"><span class="pre">Surface.map_rgb()</span></tt> and
<tt class="docutils literal"><span class="pre">Surface.unmap_rgb()</span></tt> to convert between individual red, green, and blue
values into a packed integer for that Surface.</p>
<p>Surfaces can also reference sections of other Surfaces. These are created
with the <tt class="docutils literal"><span class="pre">Surface.subsurface()</span></tt> method. Any change to either Surface will
effect the other.</p>
<p>Each Surface contains a clipping area. By default the clip area covers the
entire Surface. If it is changed, all drawing operations will only effect
the smaller area.</p>
<dl class="definition method">
<dt class="title" id="pygame.Surface.blit">
<tt class="descname">blit</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.blit" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">draw one image onto another</span></div>
<div class="line"><span class="signature">blit(source, dest, area=None, special_flags = 0) -&gt; Rect</span></div>
</div>
<p>Draws a source Surface onto this Surface. The draw can be positioned with
the dest argument. Dest can either be pair of coordinates representing
the upper left corner of the source. A Rect can also be passed as the
destination and the topleft corner of the rectangle will be used as the
position for the blit. The size of the destination rectangle does not
effect the blit.</p>
<p>An optional area rectangle can be passed as well. This represents a
smaller portion of the source Surface to draw.</p>
<p>An optional special flags is for passing in new in 1.8.0: <tt class="docutils literal"><span class="pre">BLEND_ADD</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_SUB</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_MULT</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_MIN</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_MAX</span></tt> new in 1.8.1:
<tt class="docutils literal"><span class="pre">BLEND_RGBA_ADD</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGBA_SUB</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGBA_MULT</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_RGBA_MIN</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGBA_MAX</span></tt> <tt class="docutils literal"><span class="pre">BLEND_RGB_ADD</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_RGB_SUB</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGB_MULT</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGB_MIN</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_RGB_MAX</span></tt> With other special blitting flags perhaps added in the
future.</p>
<p>The return rectangle is the area of the affected pixels, excluding any
pixels outside the destination Surface, or outside the clipping area.</p>
<p>Pixel alphas will be ignored when blitting to an 8 bit Surface.</p>
<p>special_flags new in pygame 1.8.</p>
<p>For a surface with colorkey or blanket alpha, a blit to self may give
slightly different colors than a non self-blit.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.convert">
<tt class="descname">convert</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.convert" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">change the pixel format of an image</span></div>
<div class="line"><span class="signature">convert(Surface) -&gt; Surface</span></div>
<div class="line"><span class="signature">convert(depth, flags=0) -&gt; Surface</span></div>
<div class="line"><span class="signature">convert(masks, flags=0) -&gt; Surface</span></div>
<div class="line"><span class="signature">convert() -&gt; Surface</span></div>
</div>
<p>Creates a new copy of the Surface with the pixel format changed. The new
pixel format can be determined from another existing Surface. Otherwise
depth, flags, and masks arguments can be used, similar to the
<tt class="docutils literal"><span class="pre">pygame.Surface()</span></tt> call.</p>
<p>If no arguments are passed the new Surface will have the same pixel
format as the display Surface. This is always the fastest format for
blitting. It is a good idea to convert all Surfaces before they are
blitted many times.</p>
<p>The converted Surface will have no pixel alphas. They will be stripped if
the original had them. See <tt class="docutils literal"><span class="pre">Surface.convert_alpha()</span></tt> for preserving or
creating per-pixel alphas.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.convert_alpha">
<tt class="descname">convert_alpha</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.convert_alpha" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">change the pixel format of an image including per pixel alphas</span></div>
<div class="line"><span class="signature">convert_alpha(Surface) -&gt; Surface</span></div>
<div class="line"><span class="signature">convert_alpha() -&gt; Surface</span></div>
</div>
<p>Creates a new copy of the surface with the desired pixel format. The new
surface will be in a format suited for quick blitting to the given format
with per pixel alpha. If no surface is given, the new surface will be
optimized for blitting to the current display.</p>
<p>Unlike the <tt class="docutils literal"><span class="pre">Surface.convert()</span></tt> method, the pixel format for the new
image will not be exactly the same as the requested source, but it will
be optimized for fast alpha blitting to the destination.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.copy" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">create a new copy of a Surface</span></div>
<div class="line"><span class="signature">copy() -&gt; Surface</span></div>
</div>
<p>Makes a duplicate copy of a Surface. The new Surface will have the same
pixel formats, color palettes, and transparency settings as the original.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.fill">
<tt class="descname">fill</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.fill" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">fill Surface with a solid color</span></div>
<div class="line"><span class="signature">fill(color, rect=None, special_flags=0) -&gt; Rect</span></div>
</div>
<p>Fill the Surface with a solid color. If no rect argument is given the
entire Surface will be filled. The rect argument will limit the fill to a
specific area. The fill will also be contained by the Surface clip area.</p>
<p>The color argument can be either a <tt class="docutils literal"><span class="pre">RGB</span></tt> sequence, a <tt class="docutils literal"><span class="pre">RGBA</span></tt> sequence
or a mapped color index. If using <tt class="docutils literal"><span class="pre">RGBA</span></tt>, the Alpha (A part of
<tt class="docutils literal"><span class="pre">RGBA</span></tt>) is ignored unless the surface uses per pixel alpha (Surface has
the <tt class="docutils literal"><span class="pre">SRCALPHA</span></tt> flag).</p>
<p>An optional special_flags is for passing in new in 1.8.0: <tt class="docutils literal"><span class="pre">BLEND_ADD</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_SUB</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_MULT</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_MIN</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_MAX</span></tt> new in 1.8.1:
<tt class="docutils literal"><span class="pre">BLEND_RGBA_ADD</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGBA_SUB</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGBA_MULT</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_RGBA_MIN</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGBA_MAX</span></tt> <tt class="docutils literal"><span class="pre">BLEND_RGB_ADD</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_RGB_SUB</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGB_MULT</span></tt>, <tt class="docutils literal"><span class="pre">BLEND_RGB_MIN</span></tt>,
<tt class="docutils literal"><span class="pre">BLEND_RGB_MAX</span></tt> With other special blitting flags perhaps added in the
future.</p>
<p>This will return the affected Surface area.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.scroll">
<tt class="descname">scroll</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.scroll" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">Shift the surface image in place</span></div>
<div class="line"><span class="signature">scroll(dx=0, dy=0) -&gt; None</span></div>
</div>
<p>Move the image by dx pixels right and dy pixels down. dx and dy may be
negative for left and up scrolls respectively. Areas of the surface that
are not overwritten retain their original pixel values. Scrolling is
contained by the Surface clip area. It is safe to have dx and dy values
that exceed the surface size.</p>
<p>New in Pygame 1.9</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_colorkey">
<tt class="descname">set_colorkey</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_colorkey" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">Set the transparent colorkey</span></div>
<div class="line"><span class="signature">set_colorkey(Color, flags=0) -&gt; None</span></div>
<div class="line"><span class="signature">set_colorkey(None) -&gt; None</span></div>
</div>
<p>Set the current color key for the Surface. When blitting this Surface
onto a destination, and pixels that have the same color as the colorkey
will be transparent. The color can be an <tt class="docutils literal"><span class="pre">RGB</span></tt> color or a mapped color
integer. If None is passed, the colorkey will be unset.</p>
<p>The colorkey will be ignored if the Surface is formatted to use per pixel
alpha values. The colorkey can be mixed with the full Surface alpha
value.</p>
<p>The optional flags argument can be set to <tt class="docutils literal"><span class="pre">pygame.RLEACCEL</span></tt> to provide
better performance on non accelerated displays. An <tt class="docutils literal"><span class="pre">RLEACCEL</span></tt> Surface
will be slower to modify, but quicker to blit as a source.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_colorkey">
<tt class="descname">get_colorkey</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_colorkey" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">Get the current transparent colorkey</span></div>
<div class="line"><span class="signature">get_colorkey() -&gt; RGB or None</span></div>
</div>
<p>Return the current colorkey value for the Surface. If the colorkey is not
set then None is returned.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_alpha">
<tt class="descname">set_alpha</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_alpha" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">set the alpha value for the full Surface image</span></div>
<div class="line"><span class="signature">set_alpha(value, flags=0) -&gt; None</span></div>
<div class="line"><span class="signature">set_alpha(None) -&gt; None</span></div>
</div>
<p>Set the current alpha value fo r the Surface. When blitting this Surface
onto a destination, the pixels will be drawn slightly transparent. The
alpha value is an integer from 0 to 255, 0 is fully transparent and 255
is fully opaque. If None is passed for the alpha value, then the Surface
alpha will be disabled.</p>
<p>This value is different than the per pixel Surface alpha. If the Surface
format contains per pixel alphas, then this alpha value will be ignored.
If the Surface contains per pixel alphas, setting the alpha value to None
will disable the per pixel transparency.</p>
<p>The optional flags argument can be set to <tt class="docutils literal"><span class="pre">pygame.RLEACCEL</span></tt> to provide
better performance on non accelerated displays. An <tt class="docutils literal"><span class="pre">RLEACCEL</span></tt> Surface
will be slower to modify, but quicker to blit as a source.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_alpha">
<tt class="descname">get_alpha</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_alpha" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the current Surface transparency value</span></div>
<div class="line"><span class="signature">get_alpha() -&gt; int_value or None</span></div>
</div>
<p>Return the current alpha value for the Surface. If the alpha value is not
set then None is returned.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.lock">
<tt class="descname">lock</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.lock" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">lock the Surface memory for pixel access</span></div>
<div class="line"><span class="signature">lock() -&gt; None</span></div>
</div>
<p>Lock the pixel data of a Surface for access. On accelerated Surfaces, the
pixel data may be stored in volatile video memory or nonlinear compressed
forms. When a Surface is locked the pixel memory becomes available to
access by regular software. Code that reads or writes pixel values will
need the Surface to be locked.</p>
<p>Surfaces should not remain locked for more than necessary. A locked
Surface can often not be displayed or managed by Pygame.</p>
<p>Not all Surfaces require locking. The <tt class="docutils literal"><span class="pre">Surface.mustlock()</span></tt> method can
determine if it is actually required. There is no performance penalty for
locking and unlocking a Surface that does not need it.</p>
<p>All pygame functions will automatically lock and unlock the Surface data
as needed. If a section of code is going to make calls that will
repeatedly lock and unlock the Surface many times, it can be helpful to
wrap the block inside a lock and unlock pair.</p>
<p>It is safe to nest locking and unlocking calls. The surface will only be
unlocked after the final lock is released.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.unlock">
<tt class="descname">unlock</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.unlock" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">unlock the Surface memory from pixel access</span></div>
<div class="line"><span class="signature">unlock() -&gt; None</span></div>
</div>
<p>Unlock the Surface pixel data after it has been locked. The unlocked
Surface can once again be drawn and managed by Pygame. See the
<tt class="docutils literal"><span class="pre">Surface.lock()</span></tt> documentation for more details.</p>
<p>All pygame functions will automatically lock and unlock the Surface data
as needed. If a section of code is going to make calls that will
repeatedly lock and unlock the Surface many times, it can be helpful to
wrap the block inside a lock and unlock pair.</p>
<p>It is safe to nest locking and unlocking calls. The surface will only be
unlocked after the final lock is released.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.mustlock">
<tt class="descname">mustlock</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.mustlock" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">test if the Surface requires locking</span></div>
<div class="line"><span class="signature">mustlock() -&gt; bool</span></div>
</div>
<p>Returns True if the Surface is required to be locked to access pixel
data. Usually pure software Surfaces do not require locking. This method
is rarely needed, since it is safe and quickest to just lock all Surfaces
as needed.</p>
<p>All pygame functions will automatically lock and unlock the Surface data
as needed. If a section of code is going to make calls that will
repeatedly lock and unlock the Surface many times, it can be helpful to
wrap the block inside a lock and unlock pair.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_locked">
<tt class="descname">get_locked</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_locked" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">test if the Surface is current locked</span></div>
<div class="line"><span class="signature">get_locked() -&gt; bool</span></div>
</div>
<p>Returns True when the Surface is locked. It doesn&#8217;t matter how many times
the Surface is locked.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_locks">
<tt class="descname">get_locks</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_locks" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">Gets the locks for the Surface</span></div>
<div class="line"><span class="signature">get_locks() -&gt; tuple</span></div>
</div>
<p>Returns the currently existing locks for the Surface.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_at">
<tt class="descname">get_at</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_at" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the color value at a single pixel</span></div>
<div class="line"><span class="signature">get_at((x, y)) -&gt; Color</span></div>
</div>
<p>Return a copy of the <tt class="docutils literal"><span class="pre">RGBA</span></tt> Color value at the given pixel. If the
Surface has no per pixel alpha, then the alpha value will always be 255
(opaque). If the pixel position is outside the area of the Surface an
IndexError exception will be raised.</p>
<p>Getting and setting pixels one at a time is generally too slow to be used
in a game or realtime situation. It is better to use methods which
operate on many pixels at a time like with the blit, fill and draw
methods - or by using surfarray/PixelArray.</p>
<p>This function will temporarily lock and unlock the Surface as needed.</p>
<p>Returning a Color instead of tuple, New in pygame 1.9.0. Use
<tt class="docutils literal"><span class="pre">tuple(surf.get_at((x,y)))</span></tt> if you want a tuple, and not a Color. This
should only matter if you want to use the color as a key in a dict.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_at">
<tt class="descname">set_at</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_at" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">set the color value for a single pixel</span></div>
<div class="line"><span class="signature">set_at((x, y), Color) -&gt; None</span></div>
</div>
<p>Set the <tt class="docutils literal"><span class="pre">RGBA</span></tt> or mapped integer color value for a single pixel. If the
Surface does not have per pixel alphas, the alpha value is ignored.
Settting pixels outside the Surface area or outside the Surface clipping
will have no effect.</p>
<p>Getting and setting pixels one at a time is generally too slow to be used
in a game or realtime situation.</p>
<p>This function will temporarily lock and unlock the Surface as needed.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_at_mapped">
<tt class="descname">get_at_mapped</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_at_mapped" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the mapped color value at a single pixel</span></div>
<div class="line"><span class="signature">get_at_mapped((x, y)) -&gt; Color</span></div>
</div>
<p>Return the integer value of the given pixel. If the pixel position is
outside the area of the Surface an IndexError exception will be raised.</p>
<p>This method is intended for Pygame unit testing. It unlikely has any use
in an application.</p>
<p>This function will temporarily lock and unlock the Surface as needed.</p>
<p>New in pygame. 1.9.2.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_palette">
<tt class="descname">get_palette</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_palette" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the color index palette for an 8bit Surface</span></div>
<div class="line"><span class="signature">get_palette() -&gt; [RGB, RGB, RGB, ...]</span></div>
</div>
<p>Return a list of up to 256 color elements that represent the indexed
colors used in an 8bit Surface. The returned list is a copy of the
palette, and changes will have no effect on the Surface.</p>
<p>Returning a list of <tt class="docutils literal"><span class="pre">Color(with</span> <span class="pre">length</span> <span class="pre">3)</span></tt> instances instead of tuples,
New in pygame 1.9.0</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_palette_at">
<tt class="descname">get_palette_at</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_palette_at" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the color for a single entry in a palette</span></div>
<div class="line"><span class="signature">get_palette_at(index) -&gt; RGB</span></div>
</div>
<p>Returns the red, green, and blue color values for a single index in a
Surface palette. The index should be a value from 0 to 255.</p>
<p>Returning <tt class="docutils literal"><span class="pre">Color(with</span> <span class="pre">length</span> <span class="pre">3)</span></tt> instance instead of a tuple, New in
pygame 1.9.0</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_palette">
<tt class="descname">set_palette</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_palette" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">set the color palette for an 8bit Surface</span></div>
<div class="line"><span class="signature">set_palette([RGB, RGB, RGB, ...]) -&gt; None</span></div>
</div>
<p>Set the full palette for an 8bit Surface. This will replace the colors in
the existing palette. A partial palette can be passed and only the first
colors in the original palette will be changed.</p>
<p>This function has no effect on a Surface with more than 8bits per pixel.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_palette_at">
<tt class="descname">set_palette_at</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_palette_at" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">set the color for a single index in an 8bit Surface palette</span></div>
<div class="line"><span class="signature">set_palette_at(index, RGB) -&gt; None</span></div>
</div>
<p>Set the palette value for a single entry in a Surface palette. The index
should be a value from 0 to 255.</p>
<p>This function has no effect on a Surface with more than 8bits per pixel.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.map_rgb">
<tt class="descname">map_rgb</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.map_rgb" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">convert a color into a mapped color value</span></div>
<div class="line"><span class="signature">map_rgb(Color) -&gt; mapped_int</span></div>
</div>
<p>Convert an <tt class="docutils literal"><span class="pre">RGBA</span></tt> color into the mapped integer value for this Surface.
The returned integer will contain no more bits than the bit depth of the
Surface. Mapped color values are not often used inside Pygame, but can be
passed to most functions that require a Surface and a color.</p>
<p>See the Surface object documentation for more information about colors
and pixel formats.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.unmap_rgb">
<tt class="descname">unmap_rgb</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.unmap_rgb" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">convert a mapped integer color value into a Color</span></div>
<div class="line"><span class="signature">unmap_rgb(mapped_int) -&gt; Color</span></div>
</div>
<p>Convert an mapped integer color into the <tt class="docutils literal"><span class="pre">RGB</span></tt> color components for
this Surface. Mapped color values are not often used inside Pygame, but
can be passed to most functions that require a Surface and a color.</p>
<p>See the Surface object documentation for more information about colors
and pixel formats.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_clip">
<tt class="descname">set_clip</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_clip" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">set the current clipping area of the Surface</span></div>
<div class="line"><span class="signature">set_clip(rect) -&gt; None</span></div>
<div class="line"><span class="signature">set_clip(None) -&gt; None</span></div>
</div>
<p>Each Surface has an active clipping area. This is a rectangle that
represents the only pixels on the Surface that can be modified. If None
is passed for the rectangle the full Surface will be available for
changes.</p>
<p>The clipping area is always restricted to the area of the Surface itself.
If the clip rectangle is too large it will be shrunk to fit inside the
Surface.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_clip">
<tt class="descname">get_clip</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_clip" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the current clipping area of the Surface</span></div>
<div class="line"><span class="signature">get_clip() -&gt; Rect</span></div>
</div>
<p>Return a rectangle of the current clipping area. The Surface will always
return a valid rectangle that will never be outside the bounds of the
image. If the Surface has had None set for the clipping area, the Surface
will return a rectangle with the full area of the Surface.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.subsurface">
<tt class="descname">subsurface</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.subsurface" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">create a new surface that references its parent</span></div>
<div class="line"><span class="signature">subsurface(Rect) -&gt; Surface</span></div>
</div>
<p>Returns a new Surface that shares its pixels with its new parent. The new
Surface is considered a child of the original. Modifications to either
Surface pixels will effect each other. Surface information like clipping
area and color keys are unique to each Surface.</p>
<p>The new Surface will inherit the palette, color key, and alpha settings
from its parent.</p>
<p>It is possible to have any number of subsurfaces and subsubsurfaces on
the parent. It is also possible to subsurface the display Surface if the
display mode is not hardware accelerated.</p>
<p>See the <tt class="docutils literal"><span class="pre">Surface.get_offset()</span></tt>, <tt class="docutils literal"><span class="pre">Surface.get_parent()</span></tt> to learn more
about the state of a subsurface.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_parent">
<tt class="descname">get_parent</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_parent" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">find the parent of a subsurface</span></div>
<div class="line"><span class="signature">get_parent() -&gt; Surface</span></div>
</div>
<p>Returns the parent Surface of a subsurface. If this is not a subsurface
then None will be returned.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_abs_parent">
<tt class="descname">get_abs_parent</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_abs_parent" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">find the top level parent of a subsurface</span></div>
<div class="line"><span class="signature">get_abs_parent() -&gt; Surface</span></div>
</div>
<p>Returns the parent Surface of a subsurface. If this is not a subsurface
then this surface will be returned.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_offset">
<tt class="descname">get_offset</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_offset" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">find the position of a child subsurface inside a parent</span></div>
<div class="line"><span class="signature">get_offset() -&gt; (x, y)</span></div>
</div>
<p>Get the offset position of a child subsurface inside of a parent. If the
Surface is not a subsurface this will return (0, 0).</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_abs_offset">
<tt class="descname">get_abs_offset</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_abs_offset" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">find the absolute position of a child subsurface inside its top level parent</span></div>
<div class="line"><span class="signature">get_abs_offset() -&gt; (x, y)</span></div>
</div>
<p>Get the offset position of a child subsurface inside of its top level
parent Surface. If the Surface is not a subsurface this will return (0,
0).</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_size">
<tt class="descname">get_size</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_size" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the dimensions of the Surface</span></div>
<div class="line"><span class="signature">get_size() -&gt; (width, height)</span></div>
</div>
<p>Return the width and height of the Surface in pixels.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_width">
<tt class="descname">get_width</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_width" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the width of the Surface</span></div>
<div class="line"><span class="signature">get_width() -&gt; width</span></div>
</div>
<p>Return the width of the Surface in pixels.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_height">
<tt class="descname">get_height</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_height" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the height of the Surface</span></div>
<div class="line"><span class="signature">get_height() -&gt; height</span></div>
</div>
<p>Return the height of the Surface in pixels.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_rect">
<tt class="descname">get_rect</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_rect" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the rectangular area of the Surface</span></div>
<div class="line"><span class="signature">get_rect(**kwargs) -&gt; Rect</span></div>
</div>
<p>Returns a new rectangle covering the entire surface. This rectangle will
always start at 0, 0 with a width. and height the same size as the image.</p>
<p>You can pass keyword argument values to this function. These named values
will be applied to the attributes of the Rect before it is returned. An
example would be &#8216;mysurf.get_rect(center=(100,100))&#8217; to create a
rectangle for the Surface centered at a given position.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_bitsize">
<tt class="descname">get_bitsize</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_bitsize" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the bit depth of the Surface pixel format</span></div>
<div class="line"><span class="signature">get_bitsize() -&gt; int</span></div>
</div>
<p>Returns the number of bits used to represent each pixel. This value may
not exactly fill the number of bytes used per pixel. For example a 15 bit
Surface still requires a full 2 bytes.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_bytesize">
<tt class="descname">get_bytesize</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_bytesize" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the bytes used per Surface pixel</span></div>
<div class="line"><span class="signature">get_bytesize() -&gt; int</span></div>
</div>
<p>Return the number of bytes used per pixel.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_flags">
<tt class="descname">get_flags</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_flags" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the additional flags used for the Surface</span></div>
<div class="line"><span class="signature">get_flags() -&gt; int</span></div>
</div>
<p>Returns a set of current Surface features. Each feature is a bit in the
flags bitmask. Typical flags are <tt class="docutils literal"><span class="pre">HWSURFACE</span></tt>, <tt class="docutils literal"><span class="pre">RLEACCEL</span></tt>,
<tt class="docutils literal"><span class="pre">SRCALPHA</span></tt>, and <tt class="docutils literal"><span class="pre">SRCCOLORKEY</span></tt>.</p>
<p>Here is a more complete list of flags. A full list can be found in
<tt class="docutils literal"><span class="pre">SDL_video.h</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre>SWSURFACE       0x00000000      # Surface is in system memory
HWSURFACE       0x00000001      # Surface is in video memory
ASYNCBLIT       0x00000004      # Use asynchronous blits if possible
</pre></div>
</div>
<p>Available for <tt class="docutils literal"><span class="pre">pygame.display.set_mode()</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre>ANYFORMAT       0x10000000      # Allow any video depth/pixel-format
HWPALETTE       0x20000000      # Surface has exclusive palette
DOUBLEBUF       0x40000000      # Set up double-buffered video mode
FULLSCREEN      0x80000000      # Surface is a full screen display
OPENGL        0x00000002      # Create an OpenGL rendering context
OPENGLBLIT      0x0000000A      # Create an OpenGL rendering context
                              #   and use it for blitting.  Obsolete.
RESIZABLE       0x00000010      # This video mode may be resized
NOFRAME       0x00000020        # No window caption or edge frame
</pre></div>
</div>
<p>Used internally (read-only)</p>
<div class="highlight-python"><div class="highlight"><pre>HWACCEL       0x00000100        # Blit uses hardware acceleration
SRCCOLORKEY     0x00001000      # Blit uses a source color key
RLEACCELOK      0x00002000      # Private flag
RLEACCEL        0x00004000      # Surface is RLE encoded
SRCALPHA        0x00010000      # Blit uses source alpha blending
PREALLOC        0x01000000      # Surface uses preallocated memory
</pre></div>
</div>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_pitch">
<tt class="descname">get_pitch</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_pitch" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">get the number of bytes used per Surface row</span></div>
<div class="line"><span class="signature">get_pitch() -&gt; int</span></div>
</div>
<p>Return the number of bytes separating each row in the Surface. Surfaces
in video memory are not always linearly packed. Subsurfaces will also
have a larger pitch than their real width.</p>
<p>This value is not needed for normal Pygame usage.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_masks">
<tt class="descname">get_masks</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_masks" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">the bitmasks needed to convert between a color and a mapped integer</span></div>
<div class="line"><span class="signature">get_masks() -&gt; (R, G, B, A)</span></div>
</div>
<p>Returns the bitmasks used to isolate each color in a mapped integer.</p>
<p>This value is not needed for normal Pygame usage.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_masks">
<tt class="descname">set_masks</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_masks" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">set the bitmasks needed to convert between a color and a mapped integer</span></div>
<div class="line"><span class="signature">set_masks((r,g,b,a)) -&gt; None</span></div>
</div>
<p>This is not needed for normal Pygame usage. New in pygame 1.8.1</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_shifts">
<tt class="descname">get_shifts</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_shifts" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">the bit shifts needed to convert between a color and a mapped integer</span></div>
<div class="line"><span class="signature">get_shifts() -&gt; (R, G, B, A)</span></div>
</div>
<p>Returns the pixel shifts need to convert between each color and a mapped
integer.</p>
<p>This value is not needed for normal Pygame usage.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.set_shifts">
<tt class="descname">set_shifts</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.set_shifts" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">sets the bit shifts needed to convert between a color and a mapped integer</span></div>
<div class="line"><span class="signature">set_shifts((r,g,b,a)) -&gt; None</span></div>
</div>
<p>This is not needed for normal Pygame usage. New in pygame 1.8.1</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_losses">
<tt class="descname">get_losses</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_losses" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">the significant bits used to convert between a color and a mapped integer</span></div>
<div class="line"><span class="signature">get_losses() -&gt; (R, G, B, A)</span></div>
</div>
<p>Return the least significant number of bits stripped from each color in a
mapped integer.</p>
<p>This value is not needed for normal Pygame usage.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_bounding_rect">
<tt class="descname">get_bounding_rect</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_bounding_rect" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">find the smallest rect containing data</span></div>
<div class="line"><span class="signature">get_bounding_rect(min_alpha = 1) -&gt; Rect</span></div>
</div>
<p>Returns the smallest rectangular region that contains all the pixels in
the surface that have an alpha value greater than or equal to the minimum
alpha value.</p>
<p>This function will temporarily lock and unlock the Surface as needed.</p>
<p>New in pygame 1.8.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_view">
<tt class="descname">get_view</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_view" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">return a buffer view of the Surface&#8217;s pixels.</span></div>
<div class="line"><span class="signature">get_view(&lt;kind&gt;=&#8216;2&#8217;) -&gt; BufferProxy</span></div>
</div>
<p>Return an object which exports a surface&#8217;s internal pixel buffer as
a C level array struct, Python level array interface or a C level
buffer interface. The pixel buffer is writeable. The new buffer protocol
is supported for Python 2.6 and up in CPython. The old buffer protocol
is also supported for Python 2.x. The old buffer data is in one segment
for kind &#8216;0&#8217;, multi-segment for other buffer view kinds.</p>
<p>The kind argument is the length 1 string &#8216;0&#8217;, &#8216;1&#8217;, &#8216;2&#8217;, &#8216;3&#8217;,
&#8216;r&#8217;, &#8216;g&#8217;, &#8216;b&#8217;, or &#8216;a&#8217;. The letters are case insensitive;
&#8216;A&#8217; will work as well. The argument can be either a Unicode or byte (char)
string. The default is &#8216;2&#8217;.</p>
<p>&#8216;0&#8217; returns a contiguous unstructured bytes view. No surface shape
information is given. A ValueError is raised if the surface&#8217;s pixels
are discontinuous.</p>
<p>&#8216;1&#8217; returns a (surface-width * surface-height) array of continuous
pixels. A ValueError is raised if the surface pixels are discontinuous.</p>
<p>&#8216;2&#8217; returns a (surface-width, surface-height) array of raw pixels.
The pixels are surface bytesized unsigned integers. The pixel format is
surface specific. The 3 byte unsigned integers of 24 bit surfaces are
unlikely accepted by anything other than other Pygame functions.</p>
<p>&#8216;3&#8217; returns a (surface-width, surface-height, 3) array of <tt class="docutils literal"><span class="pre">RGB</span></tt> color
components. Each of the red, green, and blue components are unsigned
bytes. Only 24-bit and 32-bit surfaces are supported. The color
components must be in either <tt class="docutils literal"><span class="pre">RGB</span></tt> or <tt class="docutils literal"><span class="pre">BGR</span></tt> order within the pixel.</p>
<p>&#8216;r&#8217; for red, &#8216;g&#8217; for green, &#8216;b&#8217; for blue, and &#8216;a&#8217; for alpha return a
(surface-width, surface-height) view of a single color component within a
surface: a color plane. Color components are unsigned bytes. Both 24-bit
and 32-bit surfaces support &#8216;r&#8217;, &#8216;g&#8217;, and &#8216;b&#8217;. Only 32-bit surfaces with
<tt class="docutils literal"><span class="pre">SRCALPHA</span></tt> support &#8216;a&#8217;.</p>
<p>The surface is locked only when an exposed interface is accessed.
For new buffer interface accesses, the surface is unlocked once the
last buffer view is released. For array interface and old buffer
interface accesses, the surface remains locked until the BufferProxy
object is released.</p>
<p>New in Pygame 1.9.2.</p>
</dd></dl>

<dl class="definition method">
<dt class="title" id="pygame.Surface.get_buffer">
<tt class="descname">get_buffer</tt><big>(</big><big>)</big><a class="headerlink" href="#pygame.Surface.get_buffer" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">acquires a buffer object for the pixels of the Surface.</span></div>
<div class="line"><span class="signature">get_buffer() -&gt; BufferProxy</span></div>
</div>
<p>Return a buffer object for the pixels of the Surface. The buffer can be
used for direct pixel access and manipulation. Surface pixel data is
represented as an unstructured block of memory, with a start address
and length in bytes. The data need not be contiguous. Any gaps are
included in the length, but otherwise ignored.</p>
<p>This method implicitly locks the Surface. The lock will be released when
the returned BufferProxy object is garbage collected.</p>
<p>New in Pygame 1.8.</p>
</dd></dl>

<dl class="definition attribute">
<dt class="title" id="pygame.Surface._pixels_address">
<tt class="descname">_pixels_address</tt><a class="headerlink" href="#pygame.Surface._pixels_address" title="Permalink to this definition">¶</a></dt>
<dd><div class="line-block">
<div class="line"><span class="summaryline">pixel buffer address</span></div>
<div class="line"><span class="signature">_pixels_address -&gt; int</span></div>
</div>
<p>The starting address of the surface&#8217;s raw pixel bytes.</p>
<p>New in Pygame 1.9.2</p>
</dd></dl>

</dd></dl>

</div>

  </div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="surfarray.html" title="pygame.surfarray"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="sprite.html" title="pygame.sprite"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Pygame v1.9.2 documentation</a> &raquo;</li>
    <script type="text/javascript" src="../_static/jquery.plugin.docscomments.js"></script>

      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Pygame Developers.
    </div>
  </body>
</html>